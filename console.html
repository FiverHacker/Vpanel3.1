{% extends "base.html" %}

{% block title %}Console - {{ vps.vps_id }} - {{ panel_name }}{% endblock %}

{% block content %}
<div class="h-screen flex flex-col">
    <!-- Header -->
    <div class="bg-white border-b p-4">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <a href="{{ url_for('vps_details', vps_id=vps.vps_id) }}" 
                   class="text-blue-500 hover:text-blue-700">
                    <i class="fas fa-arrow-left"></i>
                </a>
                <div>
                    <h1 class="text-xl font-bold">Web Console - {{ vps.vps_id }}</h1>
                    <p class="text-gray-600 text-sm">SSH access via browser</p>
                </div>
            </div>
            <div class="flex items-center space-x-3">
                <span class="status-{{ vps.status }} px-3 py-1 rounded-full text-sm">
                    {{ vps.status|title }}
                </span>
                <button onclick="toggleFullscreen()" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-expand"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Connection Form -->
    <div id="connectionForm" class="bg-gray-50 p-6 border-b">
        <div class="max-w-2xl mx-auto">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Host</label>
                    <input type="text" id="sshHost" value="127.0.0.1" 
                           class="w-full rounded-md border-gray-300 shadow-sm" readonly>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Port</label>
                    <input type="number" id="sshPort" value="{{ vps.port }}" 
                           class="w-full rounded-md border-gray-300 shadow-sm" readonly>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Username</label>
                    <input type="text" id="sshUsername" value="{{ vps.username }}" 
                           class="w-full rounded-md border-gray-300 shadow-sm" readonly>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Password</label>
                    <div class="flex space-x-2">
                        <input type="password" id="sshPassword" value="{{ vps.password }}" 
                               class="w-full rounded-md border-gray-300 shadow-sm" readonly>
                        <button onclick="togglePasswordVisibility()" type="button" 
                                class="bg-gray-200 px-3 rounded-md hover:bg-gray-300">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="mt-4 flex justify-center">
                <button onclick="connectSSH()" id="connectBtn"
                        class="btn-primary px-6 py-2 rounded-lg flex items-center space-x-2">
                    <i class="fas fa-terminal"></i>
                    <span>Connect to Console</span>
                </button>
            </div>
            <div class="mt-2 text-center text-sm text-gray-600">
                <p>Connect directly to your VPS container console</p>
            </div>
        </div>
    </div>

    <!-- Terminal Container -->
    <div id="terminalContainer" class="flex-1 bg-black hidden" style="position: relative; cursor: text;">
        <div id="terminal" class="h-full w-full p-4 font-mono text-green-400 overflow-auto" 
             style="outline: none; position: relative; white-space: pre-wrap; word-wrap: break-word;">
             <div id="terminalContent" style="min-height: 100%;"></div>
             <!-- Visible cursor that blinks -->
             <span id="terminalCursor" class="cursor-blink" style="color: #00ff00; background: #00ff00; width: 8px; display: inline-block;">â–ˆ</span>
        </div>
        <!-- Transparent input field covering entire terminal for keyboard capture -->
        <input type="text" id="terminalInput" 
               style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
                      opacity: 0; cursor: text; z-index: 10; background: transparent; 
                      border: none; outline: none; color: transparent; caret-color: #00ff00;"
               autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
               placeholder="">
    </div>

    <!-- Disconnected State -->
    <div id="disconnectedState" class="flex-1 flex items-center justify-center bg-gray-100">
        <div class="text-center">
            <i class="fas fa-terminal text-6xl text-gray-300 mb-4"></i>
            <h3 class="text-xl font-semibold text-gray-600">SSH Terminal</h3>
            <p class="text-gray-500 mt-2">Click the connect button to start your SSH session</p>
        </div>
    </div>

    <!-- Connection Status -->
    <div id="connectionStatus" class="bg-gray-800 text-white p-2 text-center hidden">
        <div class="flex items-center justify-center space-x-2">
            <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
            <span>Connected to {{ vps.vps_id }}</span>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
<script>
const socket = io('/console');
let isConnected = false;

function connectSSH() {
    const btn = document.getElementById('connectBtn');
    const originalText = btn.innerHTML;
    btn.innerHTML = '<div class="loading-spinner mx-auto"></div>';
    btn.disabled = true;

    const host = document.getElementById('sshHost').value;
    const port = document.getElementById('sshPort').value;
    const username = document.getElementById('sshUsername').value;
    const password = document.getElementById('sshPassword').value;

    // Connect directly to container console (no SSH needed)
    socket.emit('start_shell', {
        vps_id: '{{ vps.vps_id }}'
    });
}

function togglePasswordVisibility() {
    const passwordField = document.getElementById('sshPassword');
    const icon = event.target.querySelector('i') || event.target;
    if (passwordField.type === 'password') {
        passwordField.type = 'text';
        icon.className = 'fas fa-eye-slash';
    } else {
        passwordField.type = 'password';
        icon.className = 'fas fa-eye';
    }
}

function toggleFullscreen() {
    const terminalContainer = document.getElementById('terminalContainer');
    if (!document.fullscreenElement) {
        terminalContainer.requestFullscreen().catch(err => {
            console.log(`Error attempting to enable fullscreen: ${err.message}`);
        });
    } else {
        document.exitFullscreen();
    }
}

// Socket event handlers
socket.on('connect', () => {
    console.log('Connected to WebSocket');
    isConnected = false; // Reset connection state
});

socket.on('connected', (data) => {
    console.log('Console server connected:', data);
});

let currentInput = ''; // Track what user is typing

socket.on('output', (data) => {
    const terminalContent = document.getElementById('terminalContent');
    const terminal = document.getElementById('terminal');
    const terminalCursor = document.getElementById('terminalCursor');
    if (terminalContent && terminal) {
        // Append output to terminal content
        // Replace ANSI escape codes with HTML
        let processedData = data
            .replace(/\x1b\[32m/g, '<span style="color: #00ff00;">')  // Green
            .replace(/\x1b\[31m/g, '<span style="color: #ff0000;">')  // Red
            .replace(/\x1b\[33m/g, '<span style="color: #ffff00;">')  // Yellow
            .replace(/\x1b\[34m/g, '<span style="color: #0000ff;">')  // Blue
            .replace(/\x1b\[36m/g, '<span style="color: #00ffff;">')  // Cyan
            .replace(/\x1b\[35m/g, '<span style="color: #ff00ff;">')  // Magenta
            .replace(/\x1b\[0m/g, '</span>')  // Reset
            .replace(/\x1b\[m/g, '</span>')   // Reset
            .replace(/\x1b\[K/g, '')  // Clear to end of line
            .replace(/\r\n/g, '<br>')
            .replace(/\n/g, '<br>')
            .replace(/\r/g, '')
            .replace(/\x08/g, ''); // Remove backspace characters (we handle them locally)
        
        // Handle backspace sequences - remove characters before \b
        processedData = processedData.replace(/.\x08/g, ''); // Remove char + backspace
        
        // If cursor exists, move it after the new content
        if (terminalCursor && terminalContent.innerHTML.indexOf(terminalCursor.outerHTML) !== -1) {
            terminalContent.innerHTML = terminalContent.innerHTML.replace(terminalCursor.outerHTML, '');
        }
        
        terminalContent.innerHTML += processedData;
        
        // Add cursor at the end
        if (terminalCursor) {
            terminalContent.appendChild(terminalCursor);
        }
        
        terminal.scrollTop = terminal.scrollHeight;
        
        // Show terminal and hide disconnected state
        document.getElementById('terminalContainer').classList.remove('hidden');
        document.getElementById('disconnectedState').classList.add('hidden');
        document.getElementById('connectionStatus').classList.remove('hidden');
        document.getElementById('connectionForm').classList.add('hidden');
        
        // Auto-focus input field when output is received
        if (!isConnected) {
            setTimeout(() => {
                const terminalInput = document.getElementById('terminalInput');
                if (terminalInput) {
                    terminalInput.focus();
                    terminalInput.value = ''; // Clear any stale input
                    lastInputValue = '';
                }
            }, 200);
        }
        
        isConnected = true;
    }
});

socket.on('error', (error) => {
    console.error('Console error:', error);
    const btn = document.getElementById('connectBtn');
    if (btn) {
        btn.innerHTML = '<i class="fas fa-terminal"></i><span>Connect to Console</span>';
        btn.disabled = false;
    }
    
    // Show error but don't use alert for every error
    const terminal = document.getElementById('terminal');
    if (terminal && !isConnected) {
        terminal.innerHTML += '\r\n\x1b[31mError: ' + error + '\x1b[0m\r\n';
    } else if (!isConnected) {
        alert('Connection error: ' + error);
    }
});

socket.on('shell_exit', () => {
    isConnected = false;
    document.getElementById('terminalContainer').classList.add('hidden');
    document.getElementById('disconnectedState').classList.remove('hidden');
    document.getElementById('connectionStatus').classList.add('hidden');
    document.getElementById('connectionForm').classList.remove('hidden');
    document.getElementById('connectBtn').innerHTML = '<i class="fas fa-plug"></i><span>Connect to SSH</span>';
    document.getElementById('connectBtn').disabled = false;
});

// Handle terminal input - use hidden input field for better keyboard capture
const terminalInput = document.getElementById('terminalInput');
const terminal = document.getElementById('terminal');
const terminalContent = document.getElementById('terminalContent');
const terminalContainer = document.getElementById('terminalContainer');
let currentInputLine = ''; // Track current input line for display

// Focus the hidden input when clicking on terminal
terminalContainer.addEventListener('click', (e) => {
    if (isConnected && !terminalContainer.classList.contains('hidden')) {
        e.preventDefault();
        terminalInput.focus();
    }
});

terminal.addEventListener('click', (e) => {
    if (isConnected && !terminalContainer.classList.contains('hidden')) {
        e.preventDefault();
        terminalInput.focus();
    }
});

// Handle input field changes - show what user is typing in real-time (local echo)
let lastInputValue = '';
let isEchoingInput = false; // Prevent double echo

terminalInput.addEventListener('input', (e) => {
    if (!isConnected || terminalContainer.classList.contains('hidden') || isEchoingInput) {
        return;
    }
    
    const currentValue = terminalInput.value;
    const terminalCursor = document.getElementById('terminalCursor');
    
    // If value increased, user typed a character - show it immediately
    if (currentValue.length > lastInputValue.length) {
        const newChars = currentValue.slice(lastInputValue.length);
        if (terminalContent && newChars) {
            // Remove cursor temporarily
            if (terminalCursor && terminalContent.innerHTML.indexOf(terminalCursor.outerHTML) !== -1) {
                terminalContent.innerHTML = terminalContent.innerHTML.replace(terminalCursor.outerHTML, '');
            }
            // Escape HTML and add to terminal
            const escapedChars = newChars
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>');
            terminalContent.innerHTML += escapedChars;
            // Add cursor back at the end
            if (terminalCursor) {
                terminalContent.appendChild(terminalCursor);
            }
            terminal.scrollTop = terminal.scrollHeight;
        }
    } else if (currentValue.length < lastInputValue.length) {
        // Value decreased - backspace was pressed
        // Remove characters from display
        if (terminalContent) {
            const charsToRemove = lastInputValue.length - currentValue.length;
            let content = terminalContent.innerHTML;
            // Remove cursor temporarily
            if (terminalCursor && content.indexOf(terminalCursor.outerHTML) !== -1) {
                content = content.replace(terminalCursor.outerHTML, '');
            }
            // Remove last N characters (handling HTML entities)
            for (let i = 0; i < charsToRemove; i++) {
                // Remove last character, handling HTML entities and <br>
                if (content.endsWith('</span>')) {
                    // Find the span and remove it
                    const spanStart = content.lastIndexOf('<span');
                    if (spanStart !== -1) {
                        content = content.slice(0, spanStart);
                    }
                } else if (content.endsWith('<br>')) {
                    content = content.slice(0, -4);
                } else {
                    content = content.slice(0, -1);
                }
            }
            terminalContent.innerHTML = content;
            // Add cursor back at the end
            if (terminalCursor) {
                terminalContent.appendChild(terminalCursor);
            }
            terminal.scrollTop = terminal.scrollHeight;
        }
    }
    
    lastInputValue = currentValue;
});

// Handle keyboard input through the hidden input field
terminalInput.addEventListener('keydown', (e) => {
    if (!isConnected || terminalContainer.classList.contains('hidden')) {
        return;
    }
    
    let keyToSend = null;
    let shouldPreventDefault = true;
    let shouldShowChar = false;
    
    // Handle special keys
    if (e.key === 'Enter') {
        keyToSend = '\r\n';
        const terminalCursor = document.getElementById('terminalCursor');
        // Show the entered line before sending (if not already shown)
        if (terminalContent && terminalInput.value) {
            // Remove cursor temporarily
            if (terminalCursor && terminalContent.innerHTML.indexOf(terminalCursor.outerHTML) !== -1) {
                terminalContent.innerHTML = terminalContent.innerHTML.replace(terminalCursor.outerHTML, '');
            }
            const escapedValue = terminalInput.value
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            terminalContent.innerHTML += escapedValue + '<br>';
            // Add cursor back at the end
            if (terminalCursor) {
                terminalContent.appendChild(terminalCursor);
            }
            terminal.scrollTop = terminal.scrollHeight;
        }
        // Clear input field after a moment (let browser handle it naturally)
        setTimeout(() => {
            terminalInput.value = '';
            lastInputValue = '';
        }, 10);
        shouldPreventDefault = false; // Let browser handle Enter naturally
    } else if (e.key === 'Backspace') {
        keyToSend = '\b';
        // Remove last character from display if input field has content
        if (terminalInput.value.length > 0) {
            // The input field will handle backspace, we just send it to server
        }
    } else if (e.key === 'Delete') {
        keyToSend = '\x7f';
    } else if (e.key === 'Tab') {
        keyToSend = '\t';
        e.preventDefault(); // Prevent tab from moving focus
    } else if (e.key === 'Escape') {
        keyToSend = '\x1b';
    } else if (e.key === 'ArrowUp') {
        keyToSend = '\x1b[A';
    } else if (e.key === 'ArrowDown') {
        keyToSend = '\x1b[B';
    } else if (e.key === 'ArrowRight') {
        keyToSend = '\x1b[C';
    } else if (e.key === 'ArrowLeft') {
        keyToSend = '\x1b[D';
    } else if (e.key === 'Home') {
        keyToSend = '\x1b[H';
    } else if (e.key === 'End') {
        keyToSend = '\x1b[F';
    } else if (e.key === 'PageUp') {
        keyToSend = '\x1b[5~';
    } else if (e.key === 'PageDown') {
        keyToSend = '\x1b[6~';
    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
        // Regular character (but not Ctrl/Cmd/Alt combinations)
        keyToSend = e.key;
        shouldShowChar = true; // Show character as user types
    } else if (e.ctrlKey && e.key === 'c') {
        // Ctrl+C - send interrupt signal
        keyToSend = '\x03';
    } else if (e.ctrlKey && e.key === 'd') {
        // Ctrl+D - send EOF
        keyToSend = '\x04';
    } else if (e.ctrlKey && e.key === 'l') {
        // Ctrl+L - clear screen
        keyToSend = '\x0c';
        if (terminalContent) {
            terminalContent.innerHTML = '';
        }
    } else {
        shouldPreventDefault = false; // Allow browser to handle other keys
    }
    
    // Send the key if we have something to send
    if (keyToSend !== null && isConnected) {
        socket.emit('input', keyToSend);
        
        // For regular characters, show them immediately (echo locally)
        if (shouldShowChar && terminalContent) {
            // Character will be shown by input event handler
        }
        
        if (shouldPreventDefault) {
            e.preventDefault();
            e.stopPropagation();
        }
    }
    
    // Always update scroll to bottom
    setTimeout(() => {
        terminal.scrollTop = terminal.scrollHeight;
    }, 10);
});

// Keep input focused when terminal is visible and ensure it's always ready
setInterval(() => {
    if (isConnected && !terminalContainer.classList.contains('hidden')) {
        if (document.activeElement !== terminalInput) {
            terminalInput.focus();
        }
        // Ensure input field is visible and clickable
        if (terminalInput.style.opacity === '0' || terminalInput.style.opacity === '') {
            terminalInput.style.opacity = '0';
            terminalInput.style.pointerEvents = 'auto';
        }
    }
}, 100);

// Also focus on any click in terminal area
terminalContainer.addEventListener('mousedown', (e) => {
    if (isConnected && !terminalContainer.classList.contains('hidden')) {
        e.preventDefault();
        terminalInput.focus();
    }
});

// Prevent context menu on right click in terminal
terminalContainer.addEventListener('contextmenu', (e) => {
    if (isConnected) {
        e.preventDefault();
        terminalInput.focus();
    }
});

// Handle resize events
socket.on('resize', (data) => {
    socket.emit('resize', data);
});

// Handle window resize
window.addEventListener('resize', () => {
    if (isConnected) {
        const cols = Math.floor(window.innerWidth / 8);
        const rows = Math.floor(window.innerHeight / 17);
        socket.emit('resize', { cols, rows });
    }
});
</script>

<style>
#terminal {
    font-family: 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.2;
    white-space: pre-wrap;
    word-wrap: break-word;
    user-select: text;
    -webkit-user-select: text;
}

#terminal:focus {
    outline: none;
}

#terminalInput {
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: transparent;
    background: transparent;
    border: none;
    caret-color: #00ff00; /* Green cursor */
}

#terminalInput:focus {
    outline: none;
}

.cursor-blink {
    animation: blink 1s infinite;
    color: #00ff00;
}

@keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
}

.loading-spinner {
    border: 2px solid #f3f4f6;
    border-top: 2px solid #3b82f6;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>
{% endblock %}